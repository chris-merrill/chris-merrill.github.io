<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eBay Photo Studio</title>
    <!-- Favicon to prevent 404 error -->
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAPFBMVEUAAACAgIDAwMD///8AAADLy8v39/f8/Pz5+fnx8fH29vbz8/PV1dXj4+Ps7OzNzc3e3t7c3NzW1tbY2NinC7TjAAAAEHRSTlMA+/vn2NjYv7+/v39/f3/f39/f3wAAAK9JREFUeF6tlNkSwiAQRNcKIgoqKv7/n3V3bW2X9mYfth3f+0cC2H+BViR8KrhKkHACySQAQAY4pOAlAEACOCSAaQAAEgBIIACQAEACgIAAAJIASCAAkABAAgCAAAASAEgAABEACAAgAIAAAJIASCAAkABAAgCAAAASAEgAAJIASCAAkABAAgCAAAASAEgAABEACAAgAIAAAJIASCAAkABAAgCAAAASAEgAABEACAAgAIAAAJIASCAAkAD8Ay5DNaMYv3oAAAAASUVORK5CYII=">
    <!-- Prebuilt Tailwind CSS to avoid CDN warning -->
    <link href="https://unpkg.com/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/Babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-confetti@0.11.0/dist/js-confetti.browser.js"></script>
    <style>
        body {
            background-color: #111827;
            color: #f1f5f9;
            font-family: 'Inter', sans-serif;
        }
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
        }
        .flash-animation {
            animation: flash 0.3s ease-out;
        }
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        .pulse {
            animation: pulse 2s infinite ease-in-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="flash" class="flash-overlay"></div>
    <canvas id="canvas" style="display: none;"></canvas>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
            const [apiKey, setApiKey] = useState(localStorage.getItem('openai_api_key') || '');
            const [cameras, setCameras] = useState([]);
            const [selectedCamera, setSelectedCamera] = useState('');
            const [resolution, setResolution] = useState('');
            const [photos, setPhotos] = useState([]);
            const [showApiModal, setShowApiModal] = useState(!localStorage.getItem('hasSeenWelcome'));
            const [squareSize, setSquareSize] = useState(0);
            const videoRef = useRef(null);
            const canvasRef = useRef(document.getElementById('canvas'));
            const flashRef = useRef(document.getElementById('flash'));
            const jsConfetti = useRef(new JSConfetti());

            useEffect(() => {
                getCameras();
                window.addEventListener('resize', updateCropGuide);
                document.addEventListener('keydown', handleKeydown);
                return () => {
                    window.removeEventListener('resize', updateCropGuide);
                    document.removeEventListener('keydown', handleKeydown);
                    stopStream();
                };
            }, []);

            useEffect(() => {
                if (selectedCamera) initWebcam(selectedCamera);
            }, [selectedCamera]);

            const getCameras = async () => {
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true });
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    setCameras(videoDevices);
                    if (videoDevices.length > 0) setSelectedCamera(videoDevices[0].deviceId);
                } catch (err) {
                    alert('Unable to access cameras. Please grant camera permissions.');
                }
            };

            const initWebcam = async (deviceId) => {
                try {
                    if (videoRef.current.srcObject) {
                        videoRef.current.srcObject.getTracks().forEach(track => track.stop());
                    }
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: deviceId ? { exact: deviceId } : undefined,
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    videoRef.current.srcObject = stream;
                    videoRef.current.onloadedmetadata = () => {
                        updateCropGuide();
                        updateResolution();
                    };
                } catch (err) {
                    console.error('Error accessing webcam:', err);
                    alert('Failed to access webcam. Please check camera permissions or try another device.');
                }
            };

            const stopStream = () => {
                if (videoRef.current.srcObject) {
                    videoRef.current.srcObject.getTracks().forEach(track => track.stop());
                }
            };

            const updateResolution = () => {
                if (!videoRef.current.srcObject) return;
                const track = videoRef.current.srcObject.getVideoTracks()[0];
                const settings = track.getSettings();
                setResolution(`${settings.width}×${settings.height} @ ${settings.frameRate}fps`);
            };

            const updateCropGuide = () => {
                const videoWidth = videoRef.current.offsetWidth;
                const videoHeight = videoRef.current.offsetHeight;
                setSquareSize(Math.min(videoWidth, videoHeight) * 0.8);
            };

            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            const downloadBlob = (blob, filename) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 100);
            };

            const capturePhoto = async () => {
                flashRef.current.classList.add('flash-animation');
                setTimeout(() => flashRef.current.classList.remove('flash-animation'), 300);

                const context = canvasRef.current.getContext('2d');
                const scale = videoRef.current.videoWidth / videoRef.current.offsetWidth;
                const cropSize = Math.floor(squareSize * scale);
                const startX = Math.floor((videoRef.current.videoWidth - cropSize) / 2);
                const startY = Math.floor((videoRef.current.videoHeight - cropSize) / 2);

                canvasRef.current.width = 1500;
                canvasRef.current.height = 1500;
                context.drawImage(
                    videoRef.current,
                    startX, startY, cropSize, cropSize,
                    0, 0, 1500, 1500
                );

                canvasRef.current.toBlob(async (blob) => {
                    const timestamp = Date.now();
                    const date = new Date(timestamp);
                    const filename = `ebay-${date.toISOString().split('T')[0]}-${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}.jpg`;
                    downloadBlob(blob, filename);
                    const frontBase64 = await blobToBase64(blob);
                    const photoData = {
                        url: URL.createObjectURL(blob),
                        blob,
                        timestamp,
                        filename,
                        index: timestamp,
                        frontBase64,
                        hasBack: false,
                        backBase64: null,
                        details: null
                    };
                    setPhotos(prev => [photoData, ...prev].slice(0, 4));
                    if (apiKey) analyzeImage(frontBase64, null, photoData.index);
                }, 'image/jpeg', 0.95);
            };

            const captureBack = async (index) => {
                const photo = photos.find(p => p.index === index);
                if (!photo || photo.hasBack) return;

                flashRef.current.classList.add('flash-animation');
                setTimeout(() => flashRef.current.classList.remove('flash-animation'), 300);

                const context = canvasRef.current.getContext('2d');
                const scale = videoRef.current.videoWidth / videoRef.current.offsetWidth;
                const cropSize = Math.floor(squareSize * scale);
                const startX = Math.floor((videoRef.current.videoWidth - cropSize) / 2);
                const startY = Math.floor((videoRef.current.videoHeight - cropSize) / 2);

                canvasRef.current.width = 1500;
                canvasRef.current.height = 1500;
                context.drawImage(
                    videoRef.current,
                    startX, startY, cropSize, cropSize,
                    0, 0, 1500, 1500
                );

                canvasRef.current.toBlob(async (blob) => {
                    const backBase64 = await blobToBase64(blob);
                    setPhotos(prev => prev.map(p => p.index === index ? { ...p, backBase64, hasBack: true } : p));
                    if (apiKey) analyzeImage(photo.frontBase64, backBase64, index);
                }, 'image/jpeg', 0.95);
            };

            const analyzeImage = async (frontBase64, backBase64, index) => {
                const photo = photos.find(p => p.index === index);
                if (!photo) return;

                setPhotos(prev => prev.map(p => p.index === index ? { ...p, details: 'loading' } : p));

                try {
                    const messages = [
                        {
                            role: 'system',
                            content: 'You analyze trading cards, sports cards, Hot Wheels, and collectibles for eBay listings. For Hot Wheels, include the series number (like 5/5) in the title. Respond only with JSON, no other text.'
                        },
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: `Analyze these ${backBase64 ? 'product' : 'card/product'} images (front${backBase64 ? ' and back' : ''}) and create JSON for eBay listing.
${backBase64 ? 'IMPORTANT: Extract the series number (like 5/5) from the packaging if visible - this is crucial for the title.' : ''}

Return ONLY this JSON structure with extracted information:
{
  "title": "60-80 char eBay title with year brand product/player card#/model ${backBase64 ? 'series# ' : ''}features",
  "details": {
    "brand": "manufacturer name or null",
    "year": "year or null", 
    "setName": "set/series name or null",
    "cardNumber": "card/model number or null",
    "seriesNumber": "${backBase64 ? 'series like 5/5 or null' : 'null'}",
    "playerName": "player/character/model name or null",
    "team": "team if applicable or null",
    "features": [],
    "condition": "condition or null",
    "otherInfo": "other info or null"
  }
}`
                                },
                                {
                                    type: 'image_url',
                                    image_url: { url: `data:image/jpeg;base64,${frontBase64}`, detail: 'high' }
                                }
                            ]
                        }
                    ];
                    if (backBase64) {
                        messages[1].content.push({
                            type: 'image_url',
                            image_url: { url: `data:image/jpeg;base64,${backBase64}`, detail: 'high' }
                        });
                    }

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages,
                            max_tokens: 500,
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    let content = data.choices[0].message.content.trim();
                    if (content.startsWith('```json')) {
                        content = content.replace(/```json\s*/, '').replace(/```\s*$/, '');
                    }
                    const parsed = JSON.parse(content);
                    setPhotos(prev => prev.map(p => p.index === index ? { ...p, details: parsed } : p));
                    jsConfetti.current.addConfetti({ confettiNumber: 50 });
                } catch (error) {
                    setPhotos(prev => prev.map(p => p.index === index ? { ...p, details: { error: error.message } } : p));
                }
            };

            const handleKeydown = (e) => {
                if (e.code === 'Space' && e.target === document.body) {
                    e.preventDefault();
                    capturePhoto();
                }
            };

            const saveApiKey = () => {
                const key = document.getElementById('apiKeyInput').value.trim();
                if (key) {
                    localStorage.setItem('openai_api_key', key);
                    setApiKey(key);
                    setShowApiModal(false);
                    localStorage.setItem('hasSeenWelcome', 'true');
                }
            };

            const clearApiKey = () => {
                if (window.confirm('Clear API key?')) {
                    localStorage.removeItem('openai_api_key');
                    setApiKey('');
                    setShowApiModal(false);
                }
            };

            const copyTitle = (title) => {
                navigator.clipboard.writeText(title);
                alert('Title copied!');
            };

            return (
                <div className="max-w-4xl mx-auto p-4">
                    <h1 className="text-3xl font-bold text-center bg-gradient-to-r from-indigo-500 to-purple-600 bg-clip-text text-transparent mb-2">
                        eBay Photo Studio
                    </h1>
                    <p className="text-gray-400 text-center mb-6">Capture professional photos for your listings</p>

                    <div className="flex justify-center mb-4">
                        <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-lg text-sm font-medium ${apiKey ? 'bg-green-900/50 text-green-400' : 'bg-red-900/50 text-red-400'}`}>
                            <span className="w-2 h-2 rounded-full bg-current"></span>
                            {apiKey ? 'API Connected' : 'API Not Connected'}
                        </span>
                    </div>

                    <div className="relative bg-gray-800 rounded-xl p-4 shadow-lg mb-6">
                        <div className="relative">
                            <video id="video" ref={videoRef} autoPlay className="w-full rounded-lg bg-black"></video>
                            <div
                                className="absolute border-2 border-indigo-500/80 rounded-lg"
                                style={{
                                    width: `${squareSize}px`,
                                    height: `${squareSize}px`,
                                    top: '50%',
                                    left: '50%',
                                    transform: 'translate(-50%, -50%)',
                                    boxShadow: '0 0 0 9999px rgba(0, 0, 0, 0.4)'
                                }}
                            >
                                <span className="absolute -top-6 left-1/2 -translate-x-1/2 bg-indigo-500/90 text-white px-2 py-1 rounded text-xs font-semibold">
                                    Square Crop
                                </span>
                            </div>
                        </div>
                        <div className="flex justify-between mt-4">
                            <div className="flex items-center gap-2">
                                <label className="text-gray-400 text-sm font-medium">Camera:</label>
                                <select
                                    className="bg-gray-700 text-gray-100 border border-gray-600 rounded-lg px-3 py-1 text-sm"
                                    value={selectedCamera}
                                    onChange={(e) => setSelectedCamera(e.target.value)}
                                >
                                    {cameras.map((device, i) => (
                                        <option key={device.deviceId} value={device.deviceId}>
                                            {device.label || `Camera ${i + 1}`}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <span className="bg-indigo-500/10 text-indigo-400 px-3 py-1 rounded text-sm">
                                {resolution}
                            </span>
                        </div>
                    </div>

                    <div className="sticky top-0 z-10 bg-gray-900/90 py-4 mb-6 rounded-lg shadow">
                        <div className="flex justify-center gap-4">
                            <button
                                onClick={capturePhoto}
                                className="flex items-center gap-2 bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-indigo-700 pulse"
                            >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeWidth="2" d="M3 9a2 2 0 012-2h4l2-2h2l2 2h4a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                    <circle cx="12" cy="13" r="4" />
                                </svg>
                                Capture (Spacebar)
                            </button>
                            <button
                                onClick={() => setShowApiModal(true)}
                                className="bg-gray-700 text-gray-100 px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-600"
                            >
                                Configure API
                            </button>
                        </div>
                    </div>

                    <div>
                        <h2 className="text-xl font-semibold mb-2">Recent Captures</h2>
                        <p className="text-gray-400 text-sm mb-4">Click images to download • Capture both sides for better analysis</p>
                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                            {photos.map(photo => (
                                <div key={photo.index} className="bg-gray-800 rounded-lg p-4 shadow">
                                    <img
                                        src={photo.url}
                                        alt="Captured photo"
                                        className="w-full aspect-square object-cover rounded-lg mb-2 cursor-pointer"
                                        onClick={() => downloadBlob(photo.blob, photo.filename)}
                                        loading="lazy"
                                    />
                                    <div className="text-sm text-gray-400 mb-2">
                                        <div className="flex items-center gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg>
                                            {new Date(photo.timestamp).toLocaleString('en-US', {
                                                hour: 'numeric',
                                                minute: '2-digit',
                                                hour12: true,
                                                month: 'short',
                                                day: 'numeric'
                                            })}
                                        </div>
                                        <div className="font-mono text-xs bg-indigo-500/10 p-1 rounded mt-1">{photo.filename}</div>
                                    </div>
                                    {apiKey && (
                                        <>
                                            <button
                                                onClick={() => captureBack(photo.index)}
                                                className={`w-full flex items-center justify-center gap-2 text-sm px-3 py-1 rounded-lg ${photo.hasBack ? 'bg-green-900/50 text-green-400' : 'bg-indigo-600 text-white hover:bg-indigo-700'}`}
                                                disabled={photo.hasBack}
                                            >
                                                {photo.hasBack ? (
                                                    <>
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                                                        </svg>
                                                        Back Captured
                                                    </>
                                                ) : (
                                                    <>
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeWidth="2" d="M3 9a2 2 0 012-2h4l2-2h2l2 2h4a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                                        </svg>
                                                        Capture Back
                                                    </>
                                                )}
                                            </button>
                                            {photo.hasBack && (
                                                <div className="text-xs text-green-400 flex items-center gap-1 mt-2 justify-center">
                                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                                                    </svg>
                                                    Both sides captured
                                                </div>
                                            )}
                                            <div className="mt-2">
                                                {photo.details === 'loading' ? (
                                                    <div className="flex justify-center items-center h-20">
                                                        <div className="w-6 h-6 border-2 border-indigo/Uncaught (in promise) Error: A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received
500/20 border-t-indigo-500 rounded-full animate-spin"></div>
                                                    </div>
                                                ) : photo.details?.error ? (
                                                    <div className="text-red-400 text-xs text-center bg-red-900/20 p-2 rounded">
                                                        Error: {photo.details.error.includes('401') ? 'Invalid API key. Please verify your key in the Configure API settings.' : photo.details.error.includes('429') ? 'Rate limit exceeded. Please try again later.' : photo.details.error}
                                                    </div>
                                                ) : photo.details ? (
                                                    <div className="text-sm bg-indigo-500/10 p-3 rounded">
                                                        <h3 className="text-indigo-400 font-semibold mb-2">{photo.details.title}</h3>
                                                        {Object.entries(photo.details.details).map(([key, value]) => (
                                                            value && value !== 'null' && (Array.isArray(value) ? value.length > 0 && value[0] !== null : true) && (
                                                                <div key={key} className="flex gap-2 text-gray-300">
                                                                    <span className="font-medium capitalize">{key.replace(/([A-Z])/g, ' $1')}:</span>
                                                                    <span>{Array.isArray(value) ? value.join(', ') : value}</span>
                                                                </div>
                                                            )
                                                        ))}
                                                        <button
                                                            onClick={() => copyTitle(photo.details.title)}
                                                            className="w-full bg-indigo-600 text-white px-3 py-1 rounded text-sm mt-2 hover:bg-indigo-700"
                                                        >
                                                            Copy Title
                                                        </button>
                                                    </div>
                                                ) : null}
                                            </div>
                                        </>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    {showApiModal && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
                            <div className="bg-gray-800 rounded-lg p-6 max-w-md w-full">
                                <h2 className="text-xl font-semibold mb-4">Welcome to eBay Photo Studio</h2>
                                <p className="text-gray-400 mb-4">Enter your OpenAI API key to enable automatic eBay listing generation. Your key is stored locally and only sent to OpenAI. Get your key from <a href="https://platform.openai.com/account/api-keys" target="_blank" className="text-indigo-400 hover:underline">OpenAI</a>.</p>
                                <label className="block text-sm font-medium text-gray-300 mb-2">OpenAI API Key</label>
                                <input
                                    id="apiKeyInput"
                                    type="text"
                                    defaultValue={apiKey}
                                    className="w-full bg-gray-700 text-gray-100 border border-gray-600 rounded-lg px-3 py-2 mb-4 focus:outline-none focus:border-indigo-500"
                                />
                                <div className="flex justify-end gap-2">
                                    <button
                                        onClick={clearApiKey}
                                        className="px-4 py-2 bg-gray-700 text-gray-100 rounded-lg text-sm hover:bg-gray-600"
                                    >
                                        Clear Key
                                    </button>
                                    <button
                                        onClick={() => setShowApiModal(false)}
                                        className="px-4 py-2 bg-gray-700 text-gray-100 rounded-lg text-sm hover:bg-gray-600"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={saveApiKey}
                                        className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm hover:bg-indigo-700"
                                    >
                                        Save Key
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
